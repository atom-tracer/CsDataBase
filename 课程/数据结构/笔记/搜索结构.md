- 静态环境，**搜索结构**在插入和删除等操作的前后**不发生改变**。（静态搜索表）
- 动态环境，为保持较高的搜索效率, 搜索结构在执行插入和删除等操作的前后将自动进行调整，**结构可能发生变化**。（动态搜索表）
- 无论搜索成功还是失败都要返回一些信息，比如是啊比了也要报告位置，插入操作可能依赖于这个位置（比如二叉搜索树）
### 集合

- 集合是成员的一个集群，集合中的成员可以是原子（单元素），也可以是集合；集合的成员**必须互不相同**，并具有**相同的数据类型**。
- 集合的成员一般是无序的，但是在存储时通常有一定规则，为了便于合并查找等操作。

- 用位向量表示集合：用 01 表示元素是否在集合中（状态压缩）
	- ![image.png|425](https://thdlrt.oss-cn-beijing.aliyuncs.com/20240105105226.png)

- 使用有序链表表示：链表中的每个节点表示集合中的一个元素
	- ![image-20231109233325590|475](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231109233325590.png)
### 并查集

- 等价关系：自反性、对称性、传递性
- 根据等价关系划分集合得到等价类

- 并查集使用树的双亲表示，根节点为 $-k$ 表示**集合中的元素个数**（初始时都初始化为-1）
- 支持：合并、查询、构造
- ![image-20231109234451925|350](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231109234451925.png)、
- [[图论#并查集]]
### 字典

#### 字典的顺序表示

- 字典保存在线性序列中，关键码从左到右依次增大，可以使用**有序顺序表或有序链表**

- 衡量一个搜索算法的时间效率的标准是：在搜索过程中**关键码平均比较次数**，也称为**平均搜索长度 ASL**。搜索第 $i$ 个元素的概率为 $p_i$ ，搜索到时所需的比较次数为 $c_i$ ，搜索成功的平均搜索长度 $ASL_{succ}=\sum_{i=1}^{n}p_i\cdot{c_i}$

- 在有序顺序表中成功查找的平均比较次数为 $\frac1n\frac{(n+1)n}2=\frac{n+1}2$
	- 搜索不成功时不需一直比较到表尾，只要发现下一个元素的值比给定值大，就可断定搜索不成功

- 使用判定树描述顺序查找
  - 搜索成功时停在**内结点**，搜索失败时停在**外结点**
  - 判定树是一种**扩充二叉树**。内结点代表顺序表中**已有的元素**，外结点代表**失败结点**，它表示在两个**相邻已有元素值之间的值**。
  - $ASL_{unsucc}=\frac1{n+1}(\sum^n_{i=1}i+n)$
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110001215892.png" alt="image-20231110001215892" style="zoom:50%;" />

- 使用判定树描述折半查找
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110001625405.png" alt="image-20231110001625405" style="zoom:33%;" />

#### 散列表

- 不经过比较，一次直接从字典中得到搜索元素
- 在元素存储位置与其关键码之间建立**一个确定的对应函数关系** Hash ()，使得**每个关键码与唯一的存储位置相对应** `Address ＝ Hash(key)`

- 在插入时依此函数计算存储位置并**按此位置存放**。在搜索时对元素的关键码进行同样的计算，把求得的函数值当做元素存储位置，然后按此位置搜索。这就是散列方法

##### 散列函数

- 要求
  - 散列函数应是简单的，能在较短的时间内计算出结果。
  - 散列函数的定义域必须**包括需要存储的全部关键码**
  - 散列函数计算出来的地址应能**均匀分布**在整个地址空间中

- 直接定址法
  - 取关键码的线性函数值为散列地址 $Hash(key)=a*key+b$
  - 这类散列函数是**一对一的映射**，一般不会产生冲突。但它**要求散列地址空间**的大小与关键码集合的**大小相同。**（本质上就是一个数组了，占用空间太大）

- 数字分析法
  - 设有 n 个 d 位数,   每一位可能有 r 种不同的符号。这 r 种不同符号在各位上出现的频率不一定相同。根据散列表的大小,  **选取其中各种符号分布均匀的若干位**作为散列地址。
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003436992.png" alt="image-20231110003436992" style="zoom:33%;" />
    - 选取 $\lambda_k$ 小的位
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003530403.png" alt="image-20231110003530403" style="zoom:33%;" />
    - 应该取关键码的 456 位作为散列地址
  - 数字分析法仅适用于**事先明确知道表中所有关键码每一位数值的分布情况**

- 除留余数法
  - 设散列表中允许地址数为 m，取一个**不大于** m，但最接近于或等于 m 的**质数 p** 作为除数 $hash(key)=key\%p \ p<=m$
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003758347.png" alt="image-20231110003758347" style="zoom:33%;" />
  - 可按计算出的地址存放记录。注意,  **使用散列函数计算出的地址范围是 0 到 22**，而 23、24 这几个地址实际上不能用散列函数计算出来，只能在**处理冲突**时达到这些地址。

- 平方取中法
  - 首先计算构成关键码的**标识符的内码的平方**, 然后按照散列表的大小取**中间的若干位**作为散列地址。
  - 因为内码平方数的**中间几位**一般是由标识符**所有字符**决定, 所以对不同的标识符计算出的散列地址**大多不相同。**
  - 一般取散列地址为**8 的某次幂**。例如, 若散列地址总数取为 $m=8^r$，则对内码的平方数取中间的 r 位。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110003954498.png" alt="image-20231110003954498" style="zoom:33%;" />
    - 使用八进制表示

- 折叠法
  - 此方法把关键码自左到右**分成位数相等的几部分**,  每一部分的位数应与散列表地址位数相同,  只有**最后一部分的位数可以短一些**。把这些部分的**数据叠加起来**,  就可以得到具有该关键码的记录的散列地址。
  - 叠加方式
    - 移位法：把各部分**最后一位对齐相加**；
    - 分界法：各部分**不折断**，沿各部分的分界**来回折叠**, 然后对齐相加。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110004306263.png" alt="image-20231110004306263" style="zoom:33%;" />
  - 一般当关键码的位数很多，而且关键码每一位上数字的分布**大致比较均匀时**，可用这种方法得到散列地址。
  - 假设地址空间为 HT\[**400**]，利用以上函数计算，取其中 3 位，取值范围在**0～999，可能超出地址空间范围**，为此必须将 0～999 压缩到 0～399。可将计算出的地址**乘以一个压缩因子 0.4**，把计算出的地址压缩到允许范围。

#难点 
#####  冲突处理

- 闭散列方式：线性探查法
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005301946.png" alt="image-20231110005301946" style="zoom:33%;" />
  - 发生冲突时**顺次查找 $H_i=(H_{i-1}+1)\%m,i=1,2,\dots,m-1$**
    - 注意线性探测需要**在到达数组末尾时回到数组开头**
  - 搜索**成功**的平均搜索长度（**实际位置-散列位置+1**）
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005625170.png" alt="image-20231110005625170" style="zoom:33%;" />
  - 搜索**不成功**的平均搜索长度为：
    - 假设每种字母出现概率相同（这决定从什么位置开始搜索直到末尾空白）
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005807834.png" alt="image-20231110005807834" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005906375.png" alt="image-20231110005906375" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110005917223.png" alt="image-20231110005917223" style="zoom:33%;" />
  - 搜索成功的平均比对次数 $(1+1/(1-\alpha))/2$

- 开散列方式：链地址法
  - 若设散列表地址空间的位置从 0～m-1, 则关键码集合中的所有关键码被划分为 m 个子集，**具有相同地址的关键码归于同一子集**，通过一个**单链表链接**起来。我们称同一子集中的关键码互为同义词。**每一个子集称为一个桶。**
  - 所有桶号相同的表项都链接在同一个同义词子表中，各链表的表头结点**组成一个向量**。**向量的元素个数与桶数一致**。**桶号为 i**的同义词子表的表头结点是向量中第 i 个元素。
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110010357022.png" alt="image-20231110010357022" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110010406307.png" alt="image-20231110010406307" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231110010414230.png" alt="image-20231110010414230" style="zoom:33%;" />
  - 搜索成功的平均比对次数 $1+\alpha$
- 以搜索平均长度为 n / m 的同义词子表代替了搜索长度为 n 的顺序表，搜索速度快得多。

### 二叉搜索树

- 定义：二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树
  - 每个结点都有一个作为搜索依据的关键码 (key)，所有结点的**关键码互不相同**。
  - 左子树（如果非空）上所有结点的关键码都**小于**根结点的关键码。
  - 右子树（如果非空）上所有结点的关键码都**大于**根结点的关键码。
  - 左子树和右子树也是二叉搜索树。

- **中序遍历**可以得到从小到达的排序
#### 二叉树的操作

- 搜索
```c++
template<class K, class E>
BSTNode<K, E>* BST<K, E>::
Search (const K x, BSTNode<K, E> *ptr) {
//私有递归函数：在以ptr为根的二叉搜索树中搜
//索含x的结点。若找到，则函数返回该结点的
//地址，否则函数返回NULL值。
    if (ptr == NULL) return NULL; 
    else if (x < ptr->key) return Search(x, ptr->left);
    else if (x > ptr->key) return Search(x, ptr->right);
    else return ptr;				//搜索成功
};

//非递归版本
template<class K, class E>
    BSTNode<K, E>* BST<K, E>::
Search (const K x, BSTNode<K, E> *ptr) {
    //叉搜索树中搜索含x的结点。若找到，则函数返
    //回该结点的地址，否则函数返回NULL值。
    if (ptr == NULL) return NULL; 
    BSTNode<K, E>* temp = ptr;
    while (temp != NULL) {
        if (x == temp->key) return temp;
        if (x < temp->key) temp = temp->left;
        else temp = temp->right;
    }
    return NULL;
};
```
- 搜索失败到达的空节点，就是应该插入元素的位置

- 插入
```c++
template <class K, class E>
    bool BST<K, E>::Insert (const K k1, const E& e1, BSTNode<K, E> *& ptr) {	   
        //私有函数：在以ptr为根的二叉搜索树中插入值为
        //<k1,e1>的结点。若在树中已有含<k1,e1>的结点则不插入
        if (ptr == NULL) {	   //新结点作为叶结点插入
            ptr = new BSTNode<K, E>(k1,e1); //创建新结点
            if (ptr == NULL)
            { cerr << "Out of space" << endl;  exit(1); }
            return true;
        }
        else if (k1 < ptr->key) Insert (k1,e1, ptr->left);	 	//左子树插入
        else if (k1 > ptr->key) Insert (k1,e1, ptr->right);		//右子树插入
        else return false;	      //已在树中,不再插入
    };

```
- 为了向二叉搜索树中插入一个新元素，必须先检查这个元素是否在树中已经存在。即要先进行一次搜索，搜索成功测说明**不需要再插入**，搜索不成功则说明要将将新元素插入到**操作停止的位置**
- 利用二叉树的插入算法来建立二叉树
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124112504803.png" alt="image-20231124112504803" style="zoom:50%;" />

- 删除维护
  - 删除**叶结点**，只需将其双亲结点指向它的指针清零，再释放它即可。
  - 被删结点右子树为空，可以拿它的**左子女结点顶替**它的位置，再释放它。
  - 被删结点左子树为空，可以拿它的**右子女结点顶替**它的位置，再释放它。
  - 被删结点左、右子树都不为空，可以在它的**右子树中**寻找中序下的第一个结点 (关键码最小), (左子树最后一个即)用它的值填补到被删结点中，再来处理这个结点的删除问题。
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231124121813205.png" alt="image-20231124121813205" style="zoom:33%;" />
```c++
template <class K, class E>
    bool BST<K, E>::Remove (const K x, 
                            BSTNode<K, E> *& ptr) {
        //在以 ptr 为根的二叉搜索树中删除含 x 的结点
        BSTNode<K, E> *temp;
        if (ptr != NULL) {//为null表示不存在
            if (x < ptr->key) Remove (x, ptr->left);	
            //在左子树中执行删除
            else if (x > ptr->key) Remove (x, ptr->right);
            //在右子树中执行删除（找到目标了）
            else if (ptr->left != NULL && ptr->right != NULL)
            {       //ptr指示关键码为x的结点，它有两个子女
                temp = ptr->right;  
                //到右子树搜寻中序下第一个结点
                while (temp->left != NULL) 
                    temp = temp->left;
                ptr->key = temp->key;
                ptr->data = temp->data;
                //用该结点数据代替根结点数据（从右子出发去删除这个换上来的点）
                Remove (ptr->key, ptr->right);
            }
            //至少一个为空
            else {	//ptr指示关键码为x的结点有一个子女
                temp = ptr;
                if (ptr->left == NULL) ptr = ptr->right;
                else ptr = ptr->left;
                delete temp;
                return true;
            }
        }
        return false;
    }; 
```


#难点 
### AVL 树
