## 树

- 有根树的递归定义
	- ![image-20231102102434551|150](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102102434551.png)
	- 或者为空，或者为**一个根节点和多个根的子树的集合**

- 基本概念
  - 度：节点的子树数目就是节点的度，**树中度的最大值是树的度**
  - 祖先：**根结点到该结点**的路径上的**各个结点**都是该结点的祖先。
    - 直接上属：双亲
  - 子孙：某结点的**所有下属结点**，都是该结点的子孙。
    - 直接下属：子女
  - 结点的**层次**：规定**根结点在第一层**，其子女结点的层次等于它的层次加一。
  - 结点的深度：结点的**深度即为结点的层次**；离根**最远**结点的**层次即为树的深度**。
  - 结点的**高度**：规定**叶结点的高度为 1**，其双亲结点的高度等于它的高度加一。**树的高度等于根节点的高度**
  - 有序树：节点的各棵子树有次序
  - 无序树：节点的各棵子树可以互换位置
  - 同一**结点**的子女互称兄弟
  - 森林：森林是 m（m≥0）棵树的集合

### 二叉树

- 结点的一个有限集合，或者为空；或者由一个根结点加上两棵分别称为左子树右子树的互不相交的二叉树组成
- 性质
  - 深度为 k 的二叉树最少 $k$ 个结点，最多 $2^k-1$ 个（满二叉树）；n 个节点的**完全二叉树**深度 $\lceil\log_2(n+1)\rceil$
  - 设叶节点 $n_0$ 个，非叶节点 $n_2$ 个，则 $n_0=n_2+1$
- 满二叉树：有 $2^k-1$ 个结点的二叉树
- 完全二叉树：除第 k 层外全满（堆的要求）
- 二叉树的顺序表示：
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102104712509.png" alt="image-20231102104712509" style="zoom:50%;" />

- 链表表示
	- ![image-20231102151721048|350](https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102151721048.png)

#难点
#### 非递归遍历二叉树

- 前序遍历
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102153554354.png" alt="image-20231102153554354" style="zoom: 33%;" />
```c++
template <class T> 
void BinaryTree<T>::
PreOrder (void (*visit) (BinTreeNode<T> *t) ) {
     stack<BinTreeNode<T>*> S;
     BinTreeNode<T> *p = t; 
     S.Push (NULL);
	 while (p != NULL) {
          visit(p);			   //访问结点
 	      if (p->rightChild != NULL)
               S.Push (p->rightChild);  //预留右指针在栈中
          if (p->leftChild != NULL) 
               p = p->leftChild;	//进左子树
 	      else S.Pop(p);		//左子树为空
     }
};
```

- 中序遍历
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102155003400.png" alt="image-20231102155003400" style="zoom: 33%;" />
```c++
template <class T> 
void BinaryTree<T>::
InOrder (void (*visit) (BinTreeNode<T> *t)) {
     stack<BinTreeNode<T>*> S;    
      BinTreeNode<T> *p = t; 
    do {
          while (p != NULL) {	//遍历指针向左下移动
               S.Push (p); 		//该子树沿途结点进栈
               p = p->leftChild;
          }
          if (!S.IsEmpty()) {		//栈不空时退栈
               S.Pop (p);  visit (p);	//退栈, 访问
               p = p->rightChild;	//遍历指针进到右子女
          }
     } while (p != NULL || !S.IsEmpty ());
};
```

- 后序遍历
  - 定义栈的结点
    - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102155436923.png" alt="image-20231102155436923" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102155556809.png" alt="image-20231102155556809" style="zoom:50%;" />
```c++
template <class T>
    void BinaryTree<T>::
PostOrder (void (*visit) (BinTreeNode<T> *t) {
    Stack<stkNode<T>> S;   stkNode<T> w; 
    BinTreeNode<T> * p = t;     //p是遍历指针
    do {
        while (p != NULL) {	
            w.ptr = p;  w.tag = L;  S.Push (w);   
            p = p->leftChild;
        }
        int continue1 = 1;	    //继续循环标记, 用于R
        while (continue1 && !S.IsEmpty ()) {
            S.Pop (w);  p = w.ptr;
            switch (w.tag) {   	//判断栈顶的tag标记
                case L:  w.tag = R;  S.Push (w); 
                    continue1 = 0;  
                    p = p->rightChild;  break;
                case R:  visit (p);   break;	
            }
        }
    } while (!S.IsEmpty ());	//继续遍历其他结点
    cout << endl;
};
```

#### 层次遍历

- 使用一个先进先出队列，在处理上一层时，将其下一层的结点直接进到队列（的队尾）。在上一层结点遍历完后，下一层结点正好处于队列的队头，可以继续访问它们。
- <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102160454567.png" alt="image-20231102160454567" style="zoom: 33%;" />

```cpp
template <class T>
    void BinaryTree<T>::
LevelOrder (void (*visit) (BinTreeNode<T> *t)) {
    if (t == NULL) 
        return; 
    Queue<BinTreeNode<T> * > Q;
    BinTreeNode<T> *p = t;
    Q.EnQueue (p);
    while (!Q.IsEmpty ()) {
        Q.DeQueue (p);
        visit (p);
        if (p->leftChild != NULL)
            Q.EnQueue (p->leftChild);
        if (p->rightChild != NULL) 
            Q.EnQueue (p->rightChild);
    } 
}; 
```

#难点
#### 线索化二叉树

- 通过遍历二叉树可以将二叉树中所有节点的数据**排列在一个线性序列中**，可以找到前驱和后继
- 直接为每个节点添加 pred 和 succ 指针造成了浪费，没有充分使用原先树中的边。

- 利用空余的 left 和 right 指针存储前后继，使用**标志位** ltag、rtag 指明指针是指示**子女还是前驱后继**，一般用 left 存前驱，right 存后继
  - 标志位=0 表示存储的是子女结点，=1 表示存储线索
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102162242680.png" alt="image-20231102162242680" style="zoom:33%;" />
  - <img src="https://thdlrt.oss-cn-beijing.aliyuncs.com/image-20231102162305362.png" alt="image-20231102162305362" style="zoom:50%;" />
  - 实际上对于原始存在的左右节点，其 tag 均为 0，对于新创建的为1.
##### 中序线索化二叉树

| rightChild\rtag | ==0 | ==1 |
| :--- | ---- | ---- |
| ==NULL | 无此情况 | 无后继 |
| !=NULL | 后继为当前结点**右子树**的中序下的**第一个结点** | 后继为子女结点 |

| leftChild\ltag | ==0 | ==1 |
| ---- | ---- | ---- |
| ==NULL | 无此情况 | 无前驱 |
| !=NULL | 前驱为当前结点**左子树**中序下的**最后一个结点** | 前驱为左子女结点 |
##### \*具体实现

```c++
template<T>
TreadNode<T>*ThreadTree<T>::First(ThreadNode<T>*current){
    //返回以current为根的中序线索二叉树中中序序列下的第一个结点
    ThreadNode<T>*p=current;
    while(p->ltag==0)p=p->leftChild;
    return p;
}
template<T>
TreadNode<T>*ThreadTree<T>::Next(ThreadNode<T>*current){
    ThreadNode<T>*p=current->rightChild;
    if(current->rtag==0)return First(p);
    else return p;
}
template<T>
TreadNode<T>*ThreadTree<T>::Last(ThreadNode<T>*current){
    //返回以current为根的中序线索二叉树中中序序列下的最后一个结点
    ThreadNode<T>*p=current;
    while(p->rtag==0)p=p->rightChild;
    return p;
}
template<T>
TreadNode<T>*ThreadTree<T>::Prior(ThreadNode<T>*current){
    ThreadNode<T>*p=current->leftChild;
    if(current->ltag==0)return Last(p);
    else return p;
}
```

- 中序遍历建立线索化二叉树
```c++
template <class T>
struct ThreadNode {	      //线索二叉树的结点类
     int ltag, rtag;		      //线索标志
     ThreadNode<T> *leftChild, *rightChild;//线索或子女指针
     T data;			      //结点数据
     ThreadNode ( const T item)             //构造函数
          : data(item), leftChild (NULL),
            rightChild (NULL), ltag(0), rtag(0) {}	
};
template <class T>
class ThreadTree {			//线索化二叉树类
protected:
     ThreadNode<T> *root;	//树的根指针
     void createInThread (ThreadNode<T> *current,  
            ThreadNode<T> *& pre);
	    //中序遍历建立线索二叉树
     ThreadNode<T> *parent (ThreadNode<T> *t);	 
        //寻找结点t的双亲结点
public:
     ThreadTree () : root (NULL) { }	//构造函数
	void createInThread();        //建立中序线索二叉树
     ThreadNode<T> *First (ThreadNode<T> *current);
		//寻找中序下第一个结点
     ThreadNode<T> *Last (ThreadNode<T> *current);
		//寻找中序下最后一个结点
	  ThreadNode<T> *Next (ThreadNode<T> *current);
		//寻找结点在中序下的后继结点
	  ThreadNode<T> *Prior (ThreadNode<T> *current);
		//寻找结点在中序下的前驱结点
	       ………
	};
template <class T>
void ThreadTree<T>::createInThread () {
     ThreadNode<T> *pre = NULL;    //前驱结点指针
	 if (root != NULL) {   	         //非空二叉树, 线索化
          createInThread (root, pre);				    //中序遍历线索化二叉树
	      pre->rightChild = NULL;  pre->rtag = 1;		   //后处理中序最后一个结点
	 }
};
template <class T>
void ThreadTree<T>::
createInThread (ThreadNode<T> *current,ThreadNode<T> *& pre) {
//通过中序遍历，添加缺失的边进行连接, 对二叉树进行线索化
     if (current == NULL) return;
     createInThread (current->leftChild, pre);
		//递归, 左子树线索化
	 if (current->leftChild == NULL) {				//建立当前结点的前驱线索
          current->leftChild = pre;   current->ltag = 1; 
     }
     if (pre != NULL && pre->rightChild == NULL) 	    //建立前驱结点的后继线索
        { pre->rightChild = current;   pre->rtag = 1; }	
     pre = current;							   //前驱跟上,当前指针向前遍历
	 createInThread (current->rightChild,  pre);		  //递归, 右子树线索化
};//就是左中右的中序遍历模式，对于中结点双向连接
```

### 树与森林



### 堆



### Huffman 树



## 图

### 图的存储



### 最小生成树



### 最短路径

- 

#难点 
### 活动网络
